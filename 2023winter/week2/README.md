# AcWing 4645. 选数异或
给定一个长度为 n 的数列 A1,A2,⋅⋅⋅,An 和一个非负整数 x，给定 m 次查询，每次询问能否从某个区间 [l,r] 中选择两个数使得他们的异或等于 x。

## 输入格式
输入的第一行包含三个整数 n,m,x。

第二行包含 n 个整数 A1,A2,⋅⋅⋅,An。

接下来 m 行，每行包含两个整数 li,ri 表示询问区间 [li,ri]。

## 输出格式
对于每个询问，如果该区间内存在两个数的异或为 x 则输出 yes，否则输出 no。

## 数据范围
对于 20% 的评测用例，1≤n,m≤100；

对于 40% 的评测用例，1≤n,m≤1000；

对于所有评测用例，1≤n,m≤100000，0≤x<220，1≤li≤ri≤n，0≤Ai<220。

```
输入样例：
4 4 1
1 2 3 4
1 4
1 2
2 3
3 3
输出样例：
yes
no
yes
no
样例解释
显然整个数列中只有 2,3 的异或为 1。
```

# AcWing 4644. 求和
给定 n 个整数 a1,a2,⋅⋅⋅,an，求它们两两相乘再相加的和，即

S=a1⋅a2+a1⋅a3+⋅⋅⋅+a1⋅an+a2⋅a3+⋅⋅⋅+an−2⋅an−1+an−2⋅an+an−1⋅an
## 输入格式
输入的第一行包含一个整数 n。

第二行包含 n 个整数 a1,a2,⋅⋅⋅,an。

## 输出格式
输出一个整数 S，表示所求的和。

请使用合适的数据类型进行运算。

## 数据范围
对于 30% 的数据，1≤n≤1000，1≤ai≤100。

对于所有评测用例，1≤n≤200000，1≤ai≤1000。

```
输入样例：
4
1 3 6 9
输出样例：
117
```

# AcWing 4653. 数位排序
小蓝对一个数的数位之和很感兴趣，今天他要按照数位之和给数排序。

当两个数各个数位之和不同时，将数位和较小的排在前面，当数位之和相等时，将数值小的排在前面。

例如，2022 排在 409 前面，因为 2022 的数位之和是 6，小于 409 的数位之和 13。

又如，6 排在 2022 前面，因为它们的数位之和相同，而 6 小于 2022。

给定正整数 n，m，请问对 1 到 n 采用这种方法排序时，排在第 m 个的元素是多少？

## 输入格式
输入第一行包含一个正整数 n。

第二行包含一个正整数 m。

## 输出格式
输出一行包含一个整数，表示答案。

## 数据范围
对于 30% 的评测用例，1≤m≤n≤300。

对于 50% 的评测用例，1≤m≤n≤1000。

对于所有评测用例，1≤m≤n≤106。

```
输入样例：
13
5
输出样例：
3
样例解释
1 到 13 的排序为：1,10,2,11,3,12,4,13,5,6,7,8,9。

第 5 个数为 3。
```
### 一份参考
```
#pragma GCC target ("avx") //不加也能过， 只是为了让运行时间看起来赏心悦目
#pragma GCC optimize (2, 3, "Ofast", "inline", "-ffast-math")
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int cnt[N], a[N];

int main() {
    int n, m;
    cin >> n >> m;
    for(int i=1, x; i <= n; i++) {
        a[i] = x = i;
        while (x) cnt[i] += x % 10, x /= 10;
    }
    sort(a + 1, a + n + 1, [](const auto& x, const auto& y) -> bool {
        if(cnt[x] != cnt[y] ){
            return cnt[x] < cnt[y];
        }
        return x < y;
    });
    cout << a[m] << endl;
    return 0;
}
```
https://www.zhihu.com/question/474623699

